#!/usr/bin/python

# (from previous level)
# An example of a polyalphabetic cipher is called a Vigenre Cipher.  It works
# like this:
# 
# If we use the key(K)  'GOLD', and P = PROCEED MEETING AS AGREED, then "add"
# P to K, we get C.  When adding, if we exceed 25, then we roll to 0 (modulo 26).
# 
# 
# P     P R O C E   E D M E E   T I N G A   S A G R E   E D
# K     G O L D G   O L D G O   L D G O L   D G O L D   G O
# 
# becomes:
# 
# P     15 17 14 2  4  4  3 12  4 4  19  8 13 6  0  18 0  6 17 4 4   3
# K     6  14 11 3  6 14 11  3  6 14 11  3  6 14 11  3 6 14 11 3 6  14
# C     21 5  25 5 10 18 14 15 10 18  4 11 19 20 11 21 6 20  2 8 10 17
# 
# So, we get a ciphertext of:
# 
# VFZFK SOPKS ELTUL VGUCH KR

# (this level)
# Frequency analysis can break a known key length as well.  Lets try one
# last polyalphabetic cipher, but this time the key length is unknown.

# (great article)
# https://inventwithpython.com/hacking/chapter21.html

import string as st
# .ascii_uppercase
import numpy as np
# .mean
# .std (standard deviation)

# found text
found1 = "SXULWGNXIOWRZJGOFLCMRHEFZALGSPDXBLMPWIQTXJGLARIYRIBLPPCHMXMGCTZDLCLKRUYMYSJTWUTXZCMRHEFZALOTMNLBLULVMCQMGCTZDLCPTBIAVPMLNVRJNSSXWTXJGLARIQPEFUGVPPGRLGOMDKWRSIFKTZYRMQHNXDUOWQTXJGLARIQAVVTZVPLMAIVZPHCXFPAVTMLBSDOIFVTPBACSEQKOLBCRSMAMULPSPPYFCXOKHLZXUOGNLIDZVRALDOACCINRENYMLRHVXXJDXMSINBXUGIUPVRGESQSGYKQOKLMXRSIBZALBAYJMAYAVBXRSICKKPYHULWFUYHBPGVIGNXWBIQPRGVXYSSBELNZLVWIMQMGYGVSWGPWGGNARSPTXVKLPXWGDXRJHUSXQMIVTZYOGCTZRJYVBKMZHBXYVBITTPVTMOOWSAIERTASZCOITXXLYJAZQCGKPCSLZRYEMOOVCHIEKTRSREHMGNTSKVEPNNCTUNEOFIRTPPDLYAPNOGMKGCZRGNXARVMYIBLXUQPYYHGNXYOACCINQBUQAGELNRTYQIHLANTWHAYCPRJOMOKJYTVSGVLYRRSIGNKVXIMQJEGGJOMLMSGNVVERRCMRYBAGEQNPRGKLBXFLRPXRZDEJESGNXSYVBDSSZALCXYEICXXZOVTPWBLEVKZCDEAJYPCLCDXUGMARMLRWVTZLXIPLPJKKLCIREPRJYVBITPVVZPHCXFPCRGKVPSSCPBXWVXIRSSHYTUNWCGIANNUNVCOEAJLLFILECSOOLCTGCMGATSBITPPNZBVXWUPVRIHUMIBPHGUXUQPYYHNZMOKXDLZBAKLNTCCMBJTZKXRSMFSKZCSSELPUMAREBCIPKGAVCYEXNOGLNLCCJVBXHXHRHIAZBLDLZWIFYXKLMPELQGRVPAFZQNVKVZLCEMPVKPFERPMAZALVMDPKHGKKCLYOLRXTSNIBELRYNIVMKPECVXHBELNIOETUXSSYGVTZARERLVEGGNOQCYXFCXYOQYOISUKARIQHEYRHDSREFTBLEVXHMYEAJPLCXKTRFZXYOZCYXUKVVMOJLRRMAVCXFLHOKXUVEGOSARRHBSSYHQUSLXSDJINXLHPXCCVNVIPXKMFXVZLTOWQLKRYTZDLCDTVXBACSDELVYOLBCWPEERTZDTYDXFAILBRYEYEGESIHCQMPOXUDMLZVVMBUKPGECEGIWOHMFXGNXPBWKPVRSXZCEEPWVTMOOIYCXURRVBHCCSSKOLXXQSEQRTAOPWNSZKMVDLCPRTRBZRGPZAAGGKZIMAPRLKVWEAZRTXXZCSDMVVZBZRWSMNRIMZSRYXIEOVHGLGNLFZKHXKCESEKEHDIFLZRVKVFIBXSEKBTZSPEEAZMVDLCSYZGGYKGCELNTTUIGMXQHTBJKXGZRFEXABIAPMIKWARVMFKUGGFYJRSIPNBJUILDSSZALMSAVPNTXIBSMO"
found2 = "GLCYXUKFHSPEZXFAVJOWQQYYRRAYHMGIEOGARIAZYEYXVPXFPJBXXUYSLELRNXHNHPLARXTADLCCSLGENOSPRIUUMLVSNPRRJMOOGMLGUJHVBEQSMFINZDSKHEFNXKSHGEAVZAZYQCQPBAKPCLMQGRXXTYRWQSEGFHSPHZYETXFPVMXPBTWVXMLHMAZXYGEQLRNIAPOZCXIAZMVMSLRVNZNSKXCLRNJOLXXSCSHYMYKZCWPRXNWYRZJXUGMASQCELRXXDKWMYPLUGLKHTPRGAKVEWRCEIKESOVJPJGHXJYRECEGAEHDIBQSEZALDAMZXUKKZREBMIRTLLDHMHRNZMOOMPCIFVXJDMTPVBGWZSHCOIFZBUKXGZRFZALWMJOIJEBUCMBPSSZALMSYNLJOMOSXQOEZVTUNHGCXLYMYKAGEWQOLHQICLFYKLTOPJLRQOMZYFQNYEOMFGEQCEGNXYVMIPEYGKNOVBZKXKGUOPKCPBXKFDLCAEFYXUQIPDLNQBUQLGXWRRYVEXMQMGOGJREGYWBLLABEULXNTZSOSDDLNMZFGVYATRXYSKTNTRTNTAKRBXYQJRSOKQHEFXTARIPWMXKTSKVEPVFUKAYJBZKGNXYOAGWPOKTWKGIPXGUVHVEGDXBSHYBSUOVNCXYIIQDMEOYARIUPEGNXYRSJOWNTWARIUTRQYXACXMWIEGUSOJYTVGNXASHCHMYRLLBZCAVRZMFXMAPPLGMHLSSEXJUBUDLCLJGKKUYSLDMEHXKCMPTWUGESXSRRSGUULNXGWPAOZODFSEMJGGAKFCOVBUFHXHYMEEHXYKRBELRTUYOEIQEFZLPBCCDWVXMOKXULCFOKPPCMFTYKTZOWFZAPUGJYVBRIAZELWELDZNRBZOELOLBZPHDIPESPUGJYVBAYYRHMPKCYXYKFHXWZZSGYBUMSLNSEJRVEAGWPSOGKKJGYIFKTJYEJQMEKLPBJCEGUHTYLIPESPUGJYVBDXVXTIYYRELRXXUYADZVPUGJYVBELRIHUMSPOFRJVOKQZPVOKBUQEJHELYTZCMEYIQZHHZEQDIAMXYLCRSIZGBSKRBAEFYXUQIPDFLZALWEGWFROGNKPULCFNXHFMJJAEGIWOHSAJEUFOOEBESSUHADLCCSBSAHNXFPSQJBUDIPPWGLHYDLCPWGGUSSWFXIAZHMDLCCSLGENOSPRIGNTAKPRSSHMAIEXMYIXOGKYJKLRJGLZOILESTUBUDSGEEYRDPXHQLRQBTYSIRTIFUYTORALQRUNAYJGEGBTLLAYCYXYETUYXFPVQXTDOVYYHGCHWYVRPVFGGKCITPVNRFHSHQLRQZALVELOPNJRDOVCLPYRHPDIPTRTHRHMGGOIAZTAFEPTSHYIVSRRDSSZALBSYOFRZPLORRSIPUGJYVBLRQZALMSDQIRXHVWAFPRNMXUDPCXEAUYZSBRJJBXFHVPWOVRYLLNMLLFEUPUCYGESSIEVDLCDTEKMAIACWPJUKULYRGIEEPLVPIPTGCBARPYCKRYJBKVCNYSLLHXHJLVTKYSKTQESGNXWYGIPXFVTZCIBLPBTZVXLGDANEMVRMQMVRGDMKWR"
found3 = "FIPJSEJXYVCYYHZKMOYHGNEYNXSYSIPHJOMOKLYYHBTXHMLIYIRGGKKPMFHJGMJRXGNOVTZHCSLZVBALZOVKZRHTWLBLGDJYGIWOHULMFZVVKXYDXUUNNRMRAMGZXKSXQRVNBBAIELOPBTZLFMRJETGBUCXRSIYKOPDCYYHRBTUOWAPRPKHMDLCMVVYDMSVCSIUGWHQSMOPRMTUNAYDEYOMAVITLMAUYPDJMCLVYUYYALDXBIDPXKQQMGZXKCPCPONTWJVSQPEAJPLBIMQESOGLDIVEYEKAPCWFZIFGGKLYAVPRYMVYXFZYTNISKMLHIEKMYSQFPABXXHXSBOPVZMSOWJPIXIKPCTDWEKKGDSKQPXGOGNFIPJGYULLDSFTWUKTKGLGNLJOZPDMQESOKIYOWSXIQCTZWEBPSSNTPBFSEAUOVOVSMVIQLTYWSPPEFZAVEKFTXJKKLCTSYJEUFMSPYXIAZLVPWGWOBXZSKWQSMFRBUORRSSHMAUYXMQESOGLXIQDMAGVJYVBLRPKPPDLFTWFZHJUMLRWJGLHCAFTXRGLARIRZTFUYARIULZRYMOKXZCSXKNWYRRSIAKBNRFMFVVTZIOEASSEZALCTCNOFUYZKMJELNZZSSRRPHVTMOOWSYPVMAAPEPLXFKTHPEAPLNHBAEEJWCFAIWBIQDIQGGKAYGPXRJPHCWRTPYRBNRXCOYCAGKOVRSIDATPXXUTKOETWKMPZJZUBZDFPTKUZXFOWRSEGOMTEWRSEIKVVCXRSIVXHDXIPTRLKTYCKMYIOELVWINLMAYMVNVGWPGUMOOGMXTBYXKKRBCIFKKCOHCITEKLZSSLZJGKESCSLDFNTDOOLYOEUKTSDLWNSYUNYSRFTWPNXLUWYYHUOLMKGCELBAZOVMLPHOUKLPIUEVNIXZYJYYBVKMFLYRAIENTWCXFPGBTYPNILEMNRUHMLCWSEIELBOQTRGKESCSLDFNTDDOVCAVVTVPZEJWCBIVBZMCOAVZAARIALVRYHMYXFPVCKHWVIYYHCKKOKTQDIPUGKRELOGNXXZVMIPWRIHUNLYYHPRHARIQNSZKXHCMJJSSLTUNSLNSZVELDMLRLVYKLCIKMPNTVLDSYXEACAVGEQDMGZBUQJMCLVYIVBXPLMGSKSYVPJHEUIWOHMQJGULSOINELRGKYSZYWSSNBZLVCLOSGLABSSDIQNBTKRBSIFGBKDSRSIQXTDOVYDLRSHCOHFTWPNTPBXMTXVCBZREANSZSHKKXGZRCXXWKVCOJBXTFYYLRPNJRDRSKLCPUFLRIPPEGGGFDMKPXBJTFCLCXELGLRPSPXVWGKCSWJZVEEHYCLCXELUGSIEQVJBXTNORRWIZGGMBSKEIYRLVXWZLRXVELKWCESYKMTOOLZALKLZSVRPPYYHUCFYYOVTEVXHMYWVXRLCCCDWVXPLRETPSSZXUDMKPWGNXOYRMFVGUXUDIPEEVTRVEVEPRGRXTORGYXUKBYDVYGIYRBUQFYNOJGKKCELOJBXPHBHQMIGCBEDPMYHBTTUNTYCMFYBYKZYDXQKTSYJRCEIKESSREDMEOGAOPJDSAGGKMSKAEAELOYYQPCRYPLKVCBYVZXHPVCYGUNHBCIYDARREHCELPRTRBZRSLPCRYLPBRMEQHIAPXXFPLNHBAYJQFGUZKHFIJWMAMRVEVQPPSOMOSRIDMETHAYJJLXREXHBWGEMFLBMDICYCRGKZCMLNIJKLPXGCTGNSXSKWRQVBSYYKRAP"
decr1 = "ITWASTHEBESTOFTIMESITWASTHEWORSTOFTIMESITWASTHEAGEOFWISDOMITWASTHEAGEOFFOOLISHNESSITWASTHEEPOCHOFBELIEFITWASTHEEPOCHOFINCREDULITYITWASTHESEASONOFLIGHTITWASTHESEASONOFDARKNESSITWASTHESPRINGOFHOPEITWASTHEWINTEROFDESPAIRWEHADEVERYTHINGBEFOREUSWEHADNOTHINGBEFOREUSWEWEREALLGOINGDIRECTTOHEAVENWEWEREALLGOINGDIRECTTHEOTHERWAYINSHORTTHEPERIODWASSOFARLIKETHEPRESENTPERIODTHATSOMEOFITSNOISIESTAUTHORITIESINSISTEDONITSBEINGRECEIVEDFORGOODORFOREVILINTHESUPERLATIVEDEGREEOFCOMPARISONONLYTHEREWEREAKINGWITHALARGEJAWANDAQUEENWITHAPLAINFACEONTHETHRONEOFENGLANDTHEREWEREAKINGWITHALARGEJAWANDAQUEENWITHAFAIRFACEONTHETHRONEOFFRANCEINBOTHCOUNTRIESITWASCLEARERTHANCRYSTALTOTHELORDSOFTHESTATEPRESERVESOFLOAVESANDFISHESTHATTHINGSINGENERALWERESETTLEDFOREVERITWASTHEYEAROFOURLORDONETHOUSANDSEVENHUNDREDANDSEVENTYFIVESPIRITUALREVELATIONSWERECONCEDEDTOENGLANDATTHATFAVOUREDPERIODASATTHISMRSSOUTHCOTTHADRECENTLYATTAINEDHERFIVEANDTWENTIETHBLESSEDBIRTHDAYOFWHOMAPROPHETICPRIVATEINTHELIFEGUARDSHADHERALDEDTHESUBLIMEAPPEARANCEBYANNOUNCINGTHATARRANGEMENTSWEREMADEFORTHESWALLOWINGUPOFLONDONANDWESTMINSTEREVENTHECOCKLANEGHOSTHADBEENLAIDONLYAROUNDDOZENOFYEARSAFTERRAPPINGOUTITSMESSAGESASTHESPIRITSOFTHISVERYYEARLASTPASTSUPERNATURALLYDEFICIENTINORIGINALITYRAPPEDOUTTHEIRSMEREMESSAGESINTHEEARTHLYORDEROFEVENTSHADLATELYCOMETOTHEENGLISHCROWNANDPEOPLEFROMACONGRESSOFBRITISHSUBJECTSINAMERICAWHICHSTRANGETORELATEHAVEPROVEDMOREIMPORTANTTOTHEHUMANRACETHANANYCOMMUNICATIONSYETRECEIVEDTHROUGHANYOFTHECHICKENSOFTHECOCKLANEBROOD"
decr2 = "WHENTHEMAILGOTSUCCESSFULLYTODOVERINTHECOURSEOFTHEFORENOONTHEHEADDRAWERATTHEROYALGEORGEHOTELOPENEDTHECOACHDOORASHISCUSTOMWASHEDIDITWITHSOMEFLOURISHOFCEREMONYFORAMAILJOURNEYFROMLONDONINWINTERWASANACHIEVEMENTTOCONGRATULATEANADVENTUROUSTRAVELLERUPONBYTHATTIMETHEREWASONLYONEADVENTUROUSTRAVELLERLEFTBECONGRATULATEDFORTHETWOOTHERSHADBEENSETDOWNATTHEIRRESPECTIVEROADSIDEDESTINATIONSTHEMILDEWYINSIDEOFTHECOACHWITHITSDAMPANDDIRTYSTRAWITSDISAGEEABLESMELLANDITSOBSCURITYWASRATHERLIKEALARGERDOGKENNELMRLORRYTHEPASSENGERSHAKINGHIMSELFOUTOFITINCHAINSOFSTRAWATANGLEOFSHAGGYWRAPPERFLAPPINGHATANDMUDDYLEGSWASRATHERLIKEALARGERSORTOFDOGTHEREWILLBEAPACKETTOCALAISTOMORROWDRAWERYESSIRIFTHEWEATHERHOLDSANDTHEWINDSETSTOLERABLEFAIRTHETIDEWILLSERVEPRETTYNICELYATABOUTTWOINTHEAFTERNOONSIRBEDSIRISHALLNOTGOTOBEDTILLNIGHTBUTIWANTABEDROOMANDABARBERANDTHENBREAKFASTSIRYESSIRTHATWAYSIRIFYOUPLEASESHOWCONCORDGENTLEMANSVALISEANDHOTWATERTOCONCORDPULLOFFGENTLEMANSBOOTSINCONCORDYOUWILLFINDAFINESEACOALFIRESIRFETCHBARBERTOCONCORDSTIRABOUTTHERENOWFORCONCORDTHECONCORDBEDCHAMBERBEINGALWAYSASSIGNEDTOAPASSENGERBYTHEMAILANDPASSENGERSBYTHEMAILBEINGALWAYSHEAVILYWRAPPEDUPFROMHEADTOFOOTTHEROOMHADTHEODDINTERESTFORTHEESTABLISHMENTOFTHEROYALGEORGETHATALTHOUGHBUTONEKINDOFMANWASSEENTOGOINTOITALLKINDSANDVARIETIESOFMENCAMEOUTOFITCONSEQUENTLYANOTHERDRAWERANDTWOPORTERSANDSEVERALMAIDSANDTHELANDLADYWEREALLLOITERINGBYACCIDENTATVARIOUSPOINTSOFTHEROADBETWEENTHECONCORDANDTHECOFFEEROOMWHENAGENTLEMANOFSIXTYFORMALLYDRESSEDINABROWNSUITOFCLOTHESPRETTYWELLWORNBUTVERYWELLKEPTWITHLARGESQUARECUFFSANDLARGEFLAPSTOTHEPOCKETSPASSEDALONGONHISWAYTOHISBREAKFAST"
decr3 = "VERYORDERLYANDMETHODICALHELOOKEDWITHAHANDONEACHKNEEANDALOUDWATCHTICKINGASONOROUSSERMONUNDERHISFLAPPEDWAISTCOATASTHOUGHITPITTEDITSGRAVITYANDLONGEVITYAGAINSTTHELEVITYANDEVANESCENCEOFTHEBRISKFIREHEHADAGOODLEGANDWASALITTLEVAINOFITFORHISBROWNSTOCKINGSFITTEDSLEEKANDCLOSEANDWEREOFAFINETEXTUREHISSHOESANDBUCKLESTOOTHOUGHPLAINWERETRIMHEWOREANODDLITTLESLEEKCRISPFLAXENWIGSETTINGVERYCLOSETOHISHEADWHICHWIGITISTOBEPRESUMEDWASMADEOFHAIRBUTWHICHLOOKEDFARMOREASTHOUGHITWERESPUNFROMFILAMENTSOFSILKORGLASSHISLINENTHOUGHNOTOFAFINENESSINACCORDANCEWITHHISSTOCKINGSWASASWHITEASTHETOPSOFTHEWAVESTHATBROKEUPONTHENEIGHBOURINGBEACHORTHESPECKSOFSAILTHATGLINTEDINTHESUNLIGHTFARATSEAAFACEHABITUALLYSUPPRESSEDANDQUIETEDWASSTILLLIGHTEDUPUNDERTHEQUAINTWIGBYAPAIROFMOISTBRIGHTEYESTHATITMUSTHAVECOSTTHEIROWNERINYEARSGONEBYSOMEPAINSTODRILLTOTHECOMPOSEDANDRESERVEDEXPRESSIONOFTELLSONSBANKHEHADAHEALTHYCOLOURINHISCHEEKSANDHISFACETHOUGHLINEDBOREFEWTRACESOFANXIETYBUTPERHAPSTHECONFIDENTIALBACHELORCLERKSINTELLSONSBANKWEREPRINCIPALLYOCCUPIEDWITHTHECARESOFOTHERPEOPLEANDPERHAPSSECONDHANDCARESLIKESECONDHANDCLOTHESCOMEEASILYOFFANDONCOMPLETINGHISRESEMBLANCETOAMANWHOWASSITTINGFORHISPORTRAITMRLORRYDROPPEDOFFTOSLEEPTHEARRIVALOFHISBREAKFASTROUSEDHIMANDHESAIDTOTHEDRAWERASHEMOVEDHISCHAIRTOITIWISHACCOMMODATIONPREPAREDFORAYOUNGLADYWHOMAYCOMEHEREATANYTIMETODAYSHEMAYASKFORMRJARVISLORRYORSHEMAYONLYASKFORAGENTLEMANFROMTELLSONSBANKPLEASETOLETMEKNOWYESSIRTELLSONSBANKINLONDONSIRYESYESSIRWEHAVEOFTENTIMESTHEHONOURTOENTERTAINYOURGENTLEMENINTHEIRTRAVELLINGBACKWARDSANDFORWARDSBETWIXTLONDONANDPARISSIRAVASTDEALOFTRAVELLINGSIRINTELLSONANDCOMPANYSHOUSEYESWEAREQUITEAFRENCHHOUSEASWELLASANENGLISHONEYESSIRNOTMUCHINTHEHABITOFSUCHTRAVELLINGYOURSELFITHINKSIRNOTOFLATEYEARSITISFIFTEENYEARSSINCEWESINCEICAMELASTFROMFRANCE"
# The password for next level
krypton = "BELOS Z"
decrkrypt = "RANDOM"

# TOOLS
# ---------------------------------------------------------
# Index of Coincidence
def IC( datastr ):
    # Make sure the datastr is all upper and nonblank
    datastr = "".join(datastr.split())
    datastr = datastr.upper()

    # Formula: IC = (n  * (n - 1))/(N * (N - 1))
    # With
    # n: occurence of letter from alphabet in string
    # N: total number of letters in string
    n = 0.0
    r = 0.0
    t = float(len(datastr))
    t = t * (t - 1)
    for c in st.ascii_uppercase:
        o = float(datastr.count(c))
        n += o * (o - 1)
    r = n / t
    return r

# Calculate the factors of any integer greater than 2
def calc_factors( integer ):
    fact = []
    if integer < 2:
        return fact
    for i in range(2,integer + 1):
        if( integer % i == 0 ):
            fact.append( i )
    return fact

# Make sure datastring is all uppercase 
# and contains no blank chars
def clean_datastr( datastr ):
    if datastr.find(' ') or datastr.find('\n') or datastr.find('\r'):
        datastr = "".join(datastr.split())
    if not datastr.isupper():
        datastr = datastr.upper()
    return datastr

# Create block-groups of characters
def block_group( datastr, blksize ):
    datastr = clean_datastr( datastr )
    return [datastr[i:i+blksize] for i in range(0,len(datastr),blksize)]

# Create shift-groups of characters
def shift_group( datastr, blksize ):
    datastr = clean_datastr( datastr )
    return [datastr[i:i+blksize] for i in range(len(datastr)-blksize)]

# Simple Caesar Cipher per character
def rot(char, rotate):
    nr = ord(char)
    if nr > 64 and nr < 91:
        nr -= 65
        nr += rotate
        nr %= 26
        nr += 65
    return chr(nr)

# Indices of given substring in datastring
def find_indc( datastr, substr, indices=[] ):
    try:
        indx = datastr.index(substr)
    except:
        return
    if len(indices) > 0:
        indices.append(indices[-1]+indx+1)
    else:
        indices.append( indx )
    find_indc( datastr[indx+1:], substr, indices )
    return indices

# Print two dimensional list in nice columns
def column_print( data, head=[], nr_of_rows=0 ):
    # print out all the data
    if nr_of_rows == 0:
        nr_of_rows = len(data)
    # print out the head first
    if len(head) != 0:
        data = [head] + data
    # calculate the column width
    column_width = max(len(str(attr)) for row in data for attr in row[:-1]) + 2
    # print
    for row in data[:nr_of_rows+1]:
        print "".join(str(attr).ljust(column_width) for attr in row)

# Try to detect if the text is English
def score_english( text ):
    # Get all the words from the dictionare.txt file
    f = open("./dictionary.txt")
    eng_words = f.read()
    f.close()
    # Make list of dictionary and sort largest word first
    eng_words = eng_words.split()
    eng_words.sort(key = lambda s: len(s),reverse=True)
    # Calculate a score based on the remaining text
    t = float(len(text))
    for w in eng_words:
        if len(w) > len(text):
            continue
        if w in text:
            text = "".join(text.split(w))
        if len(text) == 0:
            break
    return (t - float(len(text))) / t * 100

# ANALYSE
# ---------------------------------------------------------
# IC of given keylength
def IC_analyses( datastr, keylength=1 ):
    datastr = clean_datastr( datastr )
    blocks = [''] * keylength
    ics = []
    for i in range(keylength):
        blocks[i] = "".join(
            [datastr[k] for k in range(i,len(datastr),keylength)]
        )
    for b in blocks:
        ics.append( IC(b) )
    return (np.mean(ics),np.std(ics))

# Return indices of each unique block of characters from given size
# Sorted by occurence
def block_freq_analyses( datastr, blksize=1, shift=True ):
    datastr = clean_datastr( datastr )
    diction = {}
    if shift:
        blocks = shift_group( datastr, blksize )
    else:
        blocks = block_group( datastr, blksize )

    for sub in blocks:
        if sub not in diction:
            diction[sub] = find_indc( datastr, sub, [] )

    dictlist = sorted(diction.items(),key=lambda kv: len(kv[1]),reverse=True)
    return dictlist

# Calculate the gap (and fractors) between substrings of a datastring
# You may also give it the block_freq_analyses list
def keylength_analyses( datastr, substrs ):
    diffs = []
    factors = []
    result = []
    for substr in substrs:
        if type(substr[1]) == list:
            f = substr[1]
        else:
            f = find_indc( clean_datastr( datastr ), substr )
        diffs += [f[i+1] - f[i] - 1 for i in range(0,len(f)-1,2)]
    for d in diffs:
        factors += calc_factors( d )

    result = sorted( set(factors), 
                     key=lambda k: factors.count(k),
                     reverse=True )
    return result

def block_analyses( datastr, blksize ):
    blocks = group( datastr, blksize )
    letters = {}
    for i in range(blksize):
        letters[i] = []
    for block in blocks:
        for i in range(len(block)):
            letters[i].append(block[i])
    return letters

# ENCRYPT/DECRYPT
# ---------------------------------------------------------
# Vineger cipher
def vineger( datastr, key, fn ):
    result = ''
    illegal = st.punctuation + st.whitespace
    for i in range( len(datastr) ):
        k = key[i % len(key)]
        if k == '?':
            result += datastr[i]
        elif k in illegal:
            print "Illegal char ' %s ' found in decoding key!" % k
            exit(2)
        else:
            result += rot( datastr[i], fn(ord(k)) ).lower()
    return result

def vineger_encrypt( datastr, key):
    return vineger( datastr, key, lambda k: (k - 65) )

def vineger_decrypt( datastr, key):
    return vineger( datastr, key, lambda k: 26 - (k - 65) )

# Simple Caesar cipher (ROT#)
def caesar_rot( datastr, rott, decrypt=True ):
    char = chr( rott + 65 )
    if decrypt:
        return vineger_decrypt( datastr, char )
    else:
        return vineger_encrypt( datastr, char )

# FIND KEYS
# ---------------------------------------------------------
# Caesar rotation
def find_ROT( datastr ):
    result = []
    for i in range(26):
        text = caesar( datastr, i )
        lst.append(( i, score_english(text) ))
    result.sort(key=lambda k: k[1], reverse=True)
    return result

def print_poss_keylengths():
    print "possible key-lengths:" 
    keylengths = calc_poss_keylength( [found1, found2, found3], [t[0] for t in total[1:4]])
    print keylengths

def convert_to_key( data, ii, oo, length ):
    blocks = []
    keys = []
    for datastr in data:
        blocks += group( datastr, length )
    for b in blocks:
        if ii in b:
            key = ''
            start = b.index(ii)
            for i in range(start):
                key += '-'
            for j in range(len(ii)):
                key += chr((ord(oo[j]) - ord(ii[j]) - 1) % 26 + 65)
            for k in range(start+len(ii),length):
                key += '-'
            if key not in keys:
                keys.append(key)
    return keys

def try_find_key( data ):
    # Find frequent occuring 3-blocks
    freq_an = freq_analyses( data, 3 )
    common_encr = [e[0] for e in freq_an[:15]]
    keylengths = calc_poss_keylength( data, [t[0] for t in freq_an[1:4]])
    common_words = ['THE','AND','THA','ENT','ION','TIO','FOR','NDE','HAS','NCE','EDT','TIS','OFT','STH','MEN']
    poss_keys = []
    for n in keylengths[:4]:
        for e in common_encr:
            for w in common_words:
                poss_keys += convert_to_key( data, e, w, n )
    keys = set(poss_keys)
    for k in keys:
        score1 = score_english( vineger_decipher( found1, k ) )
        score2 = score_english( vineger_decipher( found2, k ) )
        score3 = score_english( vineger_decipher( found3, k ) )
        tsc = score1 + score2 + score3
        if tsc > 9:
            print "'%s' total score: " % k + str(tsc)
            print "found1 score: %s -------------------" % str(score1)
            print vineger_decipher( found1, k ) 
            # print "found2 score: " + str(score2)
            print vineger_decipher( found2, k ) 
            # print "found3 score: " + str(score3)
            print vineger_decipher( found3, k ) 

def calc_keylengths( datastr ):
    datastr = clean_datastr( datastr )
    blocks = []
    diffs = []
    result = {}
    for b in [datastr[i:i+3] for i in range(0,len(datastr)-3,1)]:
        if b not in blocks:
            blocks.append( b )
            frq = find_indc( datastr, b, [] )
            if len(frq) > 2:
                frq.sort()
                for i in range(len(frq)-1):
                    for j in range(i+1,len(frq[i:])):
                        diffs.append( frq[j] - frq[i] )
    fact = []
    for d in diffs:
        fact += calc_factors( d )
    uniq = set( fact )
    for u in uniq:
        result[u] = fact.count( u )
    result = sorted(result.items(),
                    key=lambda kv: (kv[1],kv[0]),
                    reverse=True) 
    print result

print vineger_decrypt( found1, "KEY?ENGT?" )
